# JavaScript
황의혁

## 4_변수

- 4.1 변수란 무엇인가?
    - 변수는 프로그래밍 언어에서 **데이터를 관리**하기 위한 핵심 개념이다.
        
        메모리는 데이터를 저장할 수 있는 **메모리 셀의 집합체다**. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어 들인다.
        
         값이 저장 될 때 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의적으로 결정된다.
        
        ⇒ 따라서 동일한 컴퓨터에서 동일한 코드를 실행해도 코드가 실행될 때마다 값이 저장될 메모리 주소는 변경된다.
        
        이처럼 코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 수 없으며, 알려 주지도 않는다. 
        
        **즉, 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. =⇒ 값의 위치를 가리키는 상징적인 이름.** 
        
        **설명하기 :** 
        
        메모리는 메모리 셀의 집합이다( 1byte = 8bit)
        
        컴퓨터는 1바이트 단위로 데이터를 읽어 들이는데
        
        메모리 주소는 코드가 실행 될 때 마다 바뀐다. 
        
        그래서 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. var res  = 10 이면   ‘0x00001112’라는 주소값에 대입한다고 했을 때,  var로 res를 변수명으로 지정해주고 저 주소값을 항상 가리켜준다. 
        

- 4.2 식별자
    
    변수 이름을 ‘식별자’라고도 한다.
    
    어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
    
    식별자는 값이 아니라 **메모리 주소**를 기억하고 있는 것이다. 
    
    result ( 변수 이름 = 식별자 ) == >> 0x0669F913 ( 메모리 주소 ) == >> 30 ( 메모리 )
    
- 4.3 변수 선언
    
    변수를 선언하는 것 var, let , const 
    
    var 키워드의 단점 : block-level-scope 을 지원하지 않고 // function-level scope를 지원한다.
    
    undefined : 변수만 선언하고 데이터를 지정해주지 않았을 때.
    
    자바스크립트 엔진 2단계
    
    - 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알린다.
    - 초기화 단계 : 값을 저장을 위해 undefined를 할당해 초기화 한다.
    
    변수 이름은 어디에 등록될까 ?
    
    변수 이름과 변수 값은 실행 컨텍스트 내에 key/value형식인 객체로 등록되어 관리된다.
    
- 4.4 변수 선언의 실행 시점과 변수 호이스팅
    - 호이스팅
        - 런타임되기전 변수들이 먼저 실행된다.
- 4.5 값의 할당
- 4.6 값의 재할당
- 4.7 식별자 네이밍규칙

## 5_표현식과 문


- 5.2 리터럴
    - var score = 50 + 50      ,   50은 숫자 리터럴,  +는 연산자
    - 변수 식별자를 참조하면 변수 값으로 평가된다.
    - 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.
    - score ===== > 100으로 나오기 때문
    - 값으로 평가될 수 있는 것은 모두 표현식이다.
        - 예시)sum, person.name,arr[1],10 + 20 ,sum = 10, sum  ! == 10
    - 함수/메서드 호출 표현식
        
        square() 
        
        person.getName()
        
        **표현식은 값으로 평가된다.**
        
    - 산술 연산자 + 의 좌항과 우항에는 숫자 값이 위치해야 한다.
        
        이때 숫자 값으로 평가될 수 있는 표현식이라면 숫자 값 대신 사용할 수 있다.
        
    

- 5.4 문(statement) === 명령문
    - ⇒ 프로그램을 구성하는 **기본 단위**이자 **최소 실행 단위**다.
    - 토큰 = > 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
    - ex) v-ar sum = 1 + 2 ;   var, sum, = , 1 , + , 2;
    - 문은 여러 토큰으로 구성된다.
        - 문의 구분
            - var x;  (변수 선언문)
            - x = 10; (할당문)
            - function foo() {} (함수 선언문)
            - if( x > 1) { console.log(x); } (조건문)
            - for(var i = 0; i<2; i++) { console.log(i) }; (반복문)
            

- 5.5 세미콜론과 세미콜론 자동 삽입 기능
    - 문의 종료
        - 세미콜론은 문의 종료를 의미한다.
        - 문의 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.
        - {} 뒤에는 세미콜론을 붙히지 않는다. ⇒ 자체 종결성
        - but 세미콜론 자동삽입기능(ASI)가 있기 때문에 생략가능 즉, 옵션이다.
- 5.6 표현식인 문과 표현식이 아닌 문
    - var x; 변수 선언문은 값으로 평가 될 수 없으므로 표현식이 아니다.
    - 1, 2, 1+2, x = 1 + 2는 모두 표현식이다.
    - x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
    - 표현식과 문의 구별 방법
        - 문에는 ‘**표현식인 문’**과 ‘**표현식이 아닌 문’이 있다.**
        - 표현식이 아닌 문 ⇒ 변수 선언문
        - 표현식인 문 ⇒ 변수 할당문

## 6_데이터 타입

- 6.1 숫자 타입
    - 정수만을 위한 타입이 없고 모든 수는 실수로 처리한다.
    - ex) 1 과 1.0이 같다고 본다.
    
    ```jsx
    console.log(10/0) ==> Infinity
    console.log(10/-0) ==> -Infinity
    var x = nan; => ReferenceError: nan is not defined 
    =>nan, Nan, NAN은 식별자로 해석함.
    ```
    
- 6.2 문자열 타입
    
    ```jsx
    var string = hello;  //ReferenceError: hello is not defined
    => 문자열을 따옴표로 감싸지 않는다면 식별자로 판단.
    ```
    
- 6.3 템플릿 리터럴
    - 일반적인 문자열은 줄바꿈 허용 x
        - 일반적인 문자열에서 줄바꿈하려면 **이스케이프 시퀸스 사용해야함.**
    - 템플릿 리터럴은 벡틱(``)을 사용해 줄바꿈(개행) 사용가능
    - 표현식 삽입은 템플릿 리터럴 내에서 사용해야한다!
        - console.log(`1+2 = ${1+2}`)
- 6.4 불리언 타입
- 6.5 undefined 타입
    - 선언과 정의
        - 선언 ⇒ 변수
        - 정의 ⇒ 함수
- 6.6 null 타입
    - document.querySelector(’.myclass’)
        - myclass라는 HTML요소가 없다면 NULL
- 6.7 심벌 타입
    - 유일한 프로퍼티 키를 만들기 위해 사용?
- 6.8 객체 타입
    - 원시 타입 vs 객체 타입
        - 자바스크립트를 이루고 있는 모든 것이 객체
- 6.9 데이터 타입의 필요성
    - 데이터 공간의 활용
        - ex 숫자 타입이면 숫자 타입의 맞는 데이터 공간을 확보해준다.( 8바이트)
    - 필요성 3가지
        - 데이터 타입에 맞게 메모리 공간을 확보
        - 변수를 참조 할때 데이터 타입에 맞게 한 번의 읽어들일 메모리 공간의 크기를 결정하기 위해
        - 2진수를 어떤 데이터 타입에 맞게 해석할 건지
            - 0100 0001을 숫자로 해석하면 65
            - 문자열로 해석하면 ‘A’
- 6.10 동적 타이핑
    - 정적 타입 언어
        - c언어 ⇒ 변수 선언할 때 데이터 타입 정해진다.
    - 동적 타입 언어
        - js ⇒ 변수 선언이 아닌 할당 할때 데이터 타입이 정해진다.
        - 유연성이 좋지만 신뢰성이 떨어진다 ⇒ typescript가 나온이유( js를 동적 ⇒ 정적으로)
        

## **7_연산자**

- 산술 연산자
    - 이항 산술 연산자(+,-, / , *)
    - 단항 산술 연산자
        - 앞에 위치한 전위 증가
            
            ```jsx
            var x = 5, result;
            result = x++
            console.log(result, x) // 5,6
            전위 증가는 할당을 먼저하고, 그 다음 증가한다.
            ```
            
        - 뒤에 위치한 후위 증가
            
            ```jsx
            result = ++x
            console.log(result, x) //7,7
            ```
            
        - 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면
            
            ```jsx
            var x = '1' (문자열 타입)
            console.log(+x); //1(숫자 타입)
            ```
            
        - + 연산자는 하나 이상이 문자열일 경우에는 문자열 연결 연산자로 동작한다.
            
            ```jsx
            1 + '2' = '12'
            ```
            
- 7.2 할당 연산자
- 7.3 비교 연산자
    - ==  동등 비교
        - x와 y값이 같을때
        - 0 == ‘’ //true
        - 0 ==’0’ //true
    - === 일치 비교
        - 타입과 값이 일치해야한다.
- 7.4 삼항 연산자
    
    ```jsx
    var x = 10
    // 0은 false로 암묵적 타입이 변환된다.
    var result = x % 2 ? '홀수' : '짝수'
    //result 는 짝수.
    ```
    
- 7.5 논리 연산자
    - || 논리합(or)
    - && 논리곱(and)
    - ! 부정(not)
- 7.6 쉼표 연산자
- 7.7 그룹 연산자
    - () 친 곳을 먼저 연산
- 7.8 typeof 연산자
    
    ```jsx
    typeof 1 // 'Number'
    typeof true // 'boolean'
    typeof [] // 'object'
    typeof null // 'object' !!!!자바스크립트의 첫번째 버그 !!!!! null은 타입으로 
    																								사용하지말고 (===) 일치 연산자를 쓰자.
    ```
    
- 7.9 지수 연산자
    - 2 ** 3 = 8
    - Math.pow(2,3) = 8
- 7.10 그 외의 연산자
- 7.11 연산자의 부수 효과
    - 다른 코드의 영향을 주는 것이 부수 효과
- 7.12 연산자 우선순위
    - 책 참고
- 7.13 연산자 결합순서
    - 책 참고

## 8_제어문

- 8.1 블록문
- 8.2 조건문
    - if .. else문
        - 삼항 연산자 가능 7.4절 참고.
        
        ```jsx
        var x = 2;
        // 0은 false로 취급한다.
        var result = x % 2 ? '홀수' : '짝수';
        
        //세 개 이상도 가능한대 
        //가독성이 안좋아서 그냥 if .. else쓰는게 좋음.
        ```
        
    - switch
- 8.3 반복문
    - for, while, do ~ while(무조건 한 번은 실행)
- 8.4 break문
    - 이중 반복문일때는 break를 슨 scope에서만 나옴
- 8.5 continue문
    - 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.



## 9_타입 변환과 단축 평가

- 9.1 타입 변환이란?
    - 개발자가 의도적으로 값을 변환하는 것을 ‘명시적 타입 변환’ , ‘타입 캐스팅’
    - ‘암묵적 타입 변환’ , ‘타입 강제 변환’
        
        ```jsx
        var x = 10
        var str = x + '';
        console.log(str) // string 10
        ```
        
- 9.2 암묵적 타입 변환
    
    ```jsx
    // 피연산자가 모두 문자열 타입이어야하는 문맥
    '10' + 2 // => '102' 
    
    //피연산자가 모두 숫자 타입이어야하는 문맥
    5 * '10' // => '50'
    
    1 - '1' // => 0
    
    //수행할 수 없으므로
    1 / 'one' // => NaN
    
    //산술연산자 뿐 아니라 비교연산자도 가능하다.
    '1' > 0 // => true
    ```
    
- 9.3 명시적 타입 변환
    - 표준 빌트인 생성자 함수 ( String, Number, Boolean)를 사용하는 방법
    
    ```jsx
    Boolean('') // =>false
    Boolean(0) // => false
    
    ```
    
- 9.4 단축 평가
    - 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.
    
    ```jsx
    // 논리합에서 'Cat'만 true면 뒤에 것을 판단하지 않고 그냥 'Cat' 출력
    'Cat' || 'DOG'  => 'Cat'
    ```
    
    - 옵셔널 체이닝 연산자
        - ?.
    - 병합 연산자
        - ??
            - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환
            - 그렇지 않으면 좌항의 피연산자를 반환


## 10_객체 리터럴

- 10.1 객체란?
    - 자바스크립트에서 원시 값을 제외한 모든 값들은 대부분 객체로 이루어져 있다.
        - 원시 값 : 변경 불가능한 값//  데이터 값 자체가 안된다는 것이지 변수는 변경이 가능하다.
        - 객체 : 변경 가능한 값
        
        ```jsx
        var counter = {
        num : 0,  // 프로퍼티! //객체의 상태를 나타내는 값(data)
        increase: function() {   //메서드! : 프로퍼티를 참조하고 조작할 수 있는 동작
        this.num ++ ;
        	}
        };
        ```
        
- 10.2 객체 리터럴에 의한 객체 생성
    - 클래스 기반 객체지향 언어
        - java, C++
    - 프로토타입 기반 객체지향 언어
        - javaScript
        - 객체 생성 방법
            - 객체 리터럴
                - 리터럴이란? 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법, 객체 리터럴은 객체를 생성하기 위한 표기법.
                
                ```jsx
                객체 리터럴은 이와 같이 객체를 표기하는 방법이다.
                var counter = {
                num : 0,  // 프로퍼티! //객체의 상태를 나타내는 값(data)
                increase: function() {   //메서드! : 프로퍼티를 참조하고 조작할 수 있는 동작
                this.num ++ ;
                	}
                };
                
                ```
                
- 10.3 프로퍼티
    - 프로퍼티 키
        - 아래코드에서 ‘num’은 프퍼티 키
    - 프로퍼티 값
        - 아래코드에서 프로퍼티 키 ‘num’에  프로퍼티 값은 ‘0’이다.
    
    ```jsx
    var counter = {
    num : 0,   
    increase: function() {   //메서드! : 프로퍼티를 참조하고 조작할 수 있는 동작
    this.num ++ ;
    	}
    };
    ```
    
- 10.4 메서드
- 10.5 프로퍼티 접근
    - 마침표 프로퍼티 접근 연산자
    - 대괄호 표기법
        
        ```jsx
        var person = {
        name : 'Lee'
        };
        
        console.log(person.name) // 마침표 프로퍼티 접근 연산자
        console.log(person[name]) // 대괄호 표기법에서는 반드시 따옴표로 감싼 문자열
        													// ReferenceError : name is not defined
        
        console.log(person['name']) // Lee
        ```
        
- 10.6 프로퍼티 값 갱신
    - 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.
- 10.7 프로퍼티 동적 생성
    - 존재하지 않는 프로퍼티를 생성하면 동적으로 생성되어 추가된다.
        
        ```jsx
        var person = {
        	name : 'Lee'
        }
        
        person.age = 20
        
        console.log(person) // {name : 'Lee' , age : 20 } 동적으로 생성된다.
        ```
        
- 10.8 프로퍼티 삭제
    - delete 연산자 활용
- 10.9 ES6에서 추가된 객체 리터럴의 확장 기능


## 11_원시 값과 객체의 비교

- 11.1 원시 값
    - 원시 값은 변경 할 수 없다.
        - 숫자, 문자열, 불리언, null, undefined 인 다섯가지 기본 타입
        - 변수가 참조하던 메모리 공간의 주소가 변경된 이유
            - 변수에 할당된 원시 값이 변경 불가능하기 재할당을 통해 값을 바꿔준다.
- 문자열은 유사 배열이다.
    
    ```jsx
    var str = 'string';
    console.log(str[1]); // t
    ```
    
    - 문자열은 원시 값이기 때문에 변경 불가능한 값이다.
        
        ```jsx
        var str = 'string'
        console.log(str[0])  // s
        
        str[0] = 'A';
        console.log(str) // string
        ```
        
        - 한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없다.
        - 원시 값은 어떤 일이 있어도 불변한다.
        - 따라서 예기치 못한 변경으로부터 자유롭다
            - 즉, 신뢰성을 보장한다
            
    
- 11.2 객체 값
    - 객체를 할당한 변수는 객체를 ‘참조’ 하고 있다.
    
    ```jsx
    ver person = {
    	name : 'Lee'
    }
    가 있으면 person은 메모리 상에서 0x00001111을 가리키고 있고 가리키고 있는 곳에 있는 데이터는
    0x00001234 와 같은 참조 값을 가지고 있다. 
    그래서 person에 접근하면 주소를 참조하여 그 주소로 갈 수 있다.
    ```



     
### 12_함수

- 12.1 함수란?
    
    ```jsx
    function add(x,y){ //x,y는 매개변수
    	return x+y;  //x+y는 반환값
    }
    
    add(x,y) // 여기서 x,y는 인수(argument)
    ```
    
- 12.2 함수를 사용하는 이유
    - 신뢰성,가독성,재사용성,편리성
- 12.3 함수 리터럴
    - 리터럴은 값을 생성하기 위한 표기법.
    - 즉 함수 리터럴도 값을 생성함
    - 함수는 객체다.
- 12.4 함수 표현식
    
    ```jsx
    함수 선언문 vs 함수 표현식
    
    //함수 선언문
    function add(x,y) {
    	return x+y}
    
    //함수 표현식
    var add = function(x,y) {
    return x+y}
    ```
    
    - 함수 호이스팅
        - 함수 선언문은 런타임 이전에 실행된다.
        - 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생x  => 변수 호이스팅이 발생
        - 화살표 함수
        
        ```jsx
         var add = function add(x,y){
        return x+y}
        
        ===
        
        var add = (x,y) => x+y;
        
        function과 함수의 이름을 생략하고 '파라미터'만 그리고 'return {}' 을 '=>'로
        ```
        
- 12.7 다양한 함수의 형태
    - 즉시 실행 함수
    - 재귀 함수
    - 중첩 함수
    - 콜백 함수
    - 순수 함수와 비순수 함수
        - 순수 함수 : 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 함수
        
### 13_스코프

- 13.1 스코프란?
- 13.2 스코프의 종류
    - 전역
    - 지역
- 13.3 스코프 체인
- 13.4 함수 레벨 스코프
    - 함수에 의해 지역 스코프 생성
    - block level scope
- 13.5 렉시컬 스코프
    - 동적 스코프
        - 함수를 어디서 호출했는지가 기준이다.
    - 렉시컬 스코프(정적 스코프)
        - 함수를 어디서 지정했는지가 기준이다.

### 14_전역변수의 문제점

- 14.1 변수의 생명 주기
    - 지역 변수의 생명주기는 함수의 생명 주기와 일치한다.
- 14.2 전역 변수의 문제점
    - 암묵적 결합
    - 긴 생명 주기
    - 스코프 체인 상에서 종점에 존재한다.
    - 네임 스페이스 오염된다.
        - 다른 파일 내에서 동일한 이름으로 명명 됬을 때 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져온다.
- 14.3 전역 변수의 사용을 억제하는 방법
    - 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
    
    ```jsx
    (function () {
    	var foo = 10; // 즉시 실행 함수의 지역 변수.
    }());
    
    console.log(foo);
    ```
    

### 15_let,const 키워드와 블록 레벨 스코프

- 15.1 var 키워드로 선언한 변수의 문제점
    - 변수의 중복 허용이 가능하다.
    - var x = 1;
    - var x = 100;
        - x는 100
    - 오직 코드 블록 안에서 ex) 함수안에서 var를 쓰면 그때만 지역 스코프로 인정한다.
- 15.2 let 키워드
    - ES6이후의 var 키워드의 단점을 보완하기 위해서 도입되었다.
    - 변수 중복 선언 금지다
        - let bar = 123;
        - let bar = 456;
            - syntaxError
- 15.3 const 키워드
    - 재할당 금지
    - let, var은 재할당 가능.
    - 상태 유지와 가독성, 유지보수의 편의성을 위해서 적극적인 사용을 권장하고 있다.
    - but 변수에 객체를 할당한 경우는 값 변경이 가능하다.
    
    ```jsx
    const person = {
    			name : 'Lee'
    };
    
    person.name = 'Hwang' //가능
    ```
    

### 16_프로퍼티 어트리뷰트

- 16.1 내부 슬롯과 내부 메서드
- 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
    - 프로퍼티 생성 시 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의
- 16.3 데이터 프로퍼티와 접근자 프로퍼티
    - 데이터 프로퍼티 : 키와 값으로 구성된다.
    - 접근자 프로퍼티 : 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성한다.
- 16.4 프로퍼티 정의
- 16.5 객체 변경 방지
    - 객체 확장 금지 Object.preventExtensions
    - 객체 밀봉 Object.seal
    - 객체 동결 Object.freeze

### 17_생성자 함수에 의한 객체 생성

- 17.1 Object 생성자 함수
    
    ```jsx
    //빈 객체의 생성
    const person = new Object();
    
    person.name = 'Lee'
    person.sayHello = function() {
    	console.log('Hi, My name is ' + this.name);
    };
    
    console.log(person); // {name : 'Lee' , sayHello : f}
    person.sayHello(); // Hi! My name is Lee
    ```
    
    - 17.2 생성자 함수
        - 객체 리터럴에 의한 객체 생성 방식의 문제점
            - 직관적이고 간편하지만 단 하나의 객체 생성만 가능하다.
        - 생성자 함수에 의한 객체 생성 방식의 장점
            - 객체 생성 템플릿처럼 사용 가능
            - new 연산자와 함께 사용하면 생성자 함수로 동작
            - new 연산자 없으면 일반 함수로 동작
        - 생성자 함수의 인스턴스 생성 과정
            - 인스턴스 생성(필수) 및 생성된 인스턴스 초기화(옵션)
            - 
            
            ```jsx
            //생성자 함수
            	function Circle(radius){
            			//인스턴스 초기화
            		this.radius = radius;
            		this.getDiameter = function(){
            			return 2 * this.radius;
            		};
            }
            
            const circles1 = new Circle(5); //반지름이 5인 Circle 객체 생성
            ```
            
        - new.target
            - this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역변수와 함께 생성

### 18_함수와 일급 객체

- 18.1 일급 객체
    - 무명의 리터럴로 생성가능
    - 변수나 자료구조 저장 가능
    - 함수의 반환값으로 사용 가능
- 18.2 함수 객체의  프로퍼티
    
    ```jsx
    funciton square(number){
    		return number * number;
    }
    
    console.log(square);
    
    ```
    
    - 브라우저 콘솔에서 console.dir 메서드를 사용하여 함수 객체 내부 확인
    - square 함수의 모든 프로퍼티 어트리뷰트를 Object.getOwnPropertyDescriptors 메서드로 확인 가능 하다.
    - arguments 프로퍼티
    - caller 프로퍼티
    
    - length 프로퍼티
    - name 프로퍼티
    - proto 접근자 프로퍼티
    - prototype 프로퍼티
### 19_프로토타입

- 19 프로토타입
    - 클래스와 생성자 함수
        - 두 개 모두 ‘프로토타입 기반’의 ‘인스턴트’를 생성하지만 정확히 동일하게 동작하지 않는다
            - 프로토타입이란? ‘기존의 객체를 복사해서 새로운 객체를 만든다’라는 개념
    - 자바스크립트를 이루고 있는 거의 모든 것이 ‘객체’이다
- 19.1 객체 지향 프로그래밍
- 19.2 상속과 프로토타입
    - 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.
    
    ```jsx
    //생성자 함수 Circle을 생성했다.
    function Circle(radius){
    	this.radius = radius
    }
    
    //Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
    //공유해서 사용할 수 있도록 프로토타입에 추가한다.
    //프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩 되어있다.
    
    Circle.prototype.getArea = function(){
    	return Math.PI * this.radius ** 2
    }
    
    //인스턴스 생성
    const circle1 = new Circle(1)
    const circle2 = new Circle(2)
    ```
### 20_ strict mode

- 20.1 strict mode란?

```jsx
function foo(){
	x = 10;
}
foo()
console.log(x)

```

오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는 것이 오류를 줄이기 쉬운 근본적인 방법이다.

- 20.2 strict mode의 적용
    - 전역의 선두 or 함수 몸체 선두에
    - ‘use strict’;를 추가한다.
    - 
    
    ```jsx
    'use strict'
    
    function foo(){
    	x = 10;
    }
    foo();
    
    function foo(){
    	`use strict';
    	x = 10;
    }
    foo()
    ```
    
- 20.3 전역에 strict mode를 적용하는 것은 피하자
    - 
- 20.4 함수 단위로 strict mode를 적용하는 것도 피하자
- 20.5 strict mode가 발생시키는 에러
    - 암묵적 전역
        - 변수를 선언하지 않았을 경우
    - 변수, 함수, 매개변수의 삭제
        - 삭제하면 SyntaxError가 발생한다.
    - 매개변수 이름이 중복이면 SyntaxError가 발생한다.
    - with문의 사용
- 20.6 strict mode 적용에 의한 변화
    - strict mode에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다.
    - 생성자 함수가 아닌 일반 함수내부에서는 this를 사용할 필요가 없기 때문이다.
    

### 21_빌트인 객체

- 21.1 자바스크립트 객체의 분류
    - 표준 빌트인 객체
    - 호스트 객체
    - 사용자 정의 객체
- 21.2 표준 빌트인 객체
    - Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체!
- 21.3 원시값과 래퍼 객체
    - 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 wrapper 객체라고 한다.
- 21.4 전역 객체
    - 브라우저 환경
        - self,this,frames
    - Node.js 환경
        - global

### 퀴즈 19~21

1. console.log(obj.x)의 출력값은 무엇인가요? 
    
    ```jsx
    const obj = {};
    const parent = {x : 1};
    
    Object.getPrototypeOf(obj);
    Object.setPrototypeOf(obj,parent);
    
    console.log(obj.x)
    ```
    

 2. strict mode의 적용이 되지 않는 것은?

```jsx
1번:
'use strict';

function foo(){
	x = 10;
}
foo();

2번:
function foo(){
	'use strict';
	
  x = 10;
}
foo();

3번
function foo(){
	x = 10;
	'use strict';
}
foo();
```

1. 자바스크립트 객체를 크게 3가지 객체로 분류할 수 있습니다.
    1. 
    2. 
    3. 

정답

1 → 1이 출력됩니다

2 → 3

3 → a : 표준 빌트인 객체, b : 호스트 객체, c : 사용자 정의 객체,

### 22_this

- 22.1 this 키워드
    
    ```jsx
     const person = {
    	name : 'Lee',
    	getName() {
    		//메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다.
    		console.log(this); // {name : 'Lee' , getName : f}
    		return this.name;
    ```
    
- 22.2 함수 호출 방식과 this 바인딩
    - this 바인딩(this에 바인딩될 값)은 함수 호출 방식,
    - 즉 함수가 어떻게 호출 되었는지에 따라 동적으로 결정된다.
    
    ```jsx
    // this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.
    
    const foo = function (){
    	console.dir(this);
    };
    
    // 동일한 함수도 다양한 방식으로 호출 될 수 있다.
    
    // 1. 일반 함수 호출
    // foo 함수를 일반적인 방식으로 호출한다.
    // foo 함수 내부의 this는 전역 객체 window를 가리킨다.
    foo(); // window
    
    //2. 메서드 호출
    //foo 함수를 프로퍼티 값으로 할당하여 호출
    //foo 함수 내부의 this는 메서드를 호출하 객체 obj를 가리킨다.
    const obj = { foo };
    obg.foo(); // obj
    
    //3. 생성자 호출
    // foo 함수를 new 연산자와 함께 생성자 함수로 호출
    // foo 함수 내부의 this는 생성자 함수가 생성한 인스턴스를 가리킨다.
    new foo(); //foo {}
    
    ```
    
## 배열
   - 메서드
   	indexOf 
	push
	pop
	unshift
	shift
	concat
	splice 
	slice
	join
	reverse
	fill
	includes
	flat
	sort
##String
  - 메서드
 	indexOf
	search
	includes
	startsWith
	endsWith
	charAt
	substring
	slice
	toLowerCase
	toUpperCase
	trim
	repeat
	replace
	split
## 퀴즈
<code>
    - **다음의 코드 실행 결과는?**

console.log(score);    

score = 40;

var score;

console.log(score);

정답 : //undifinded
    
      // 40
        
-  **다음 중 가능한 변수 네이밍 방식을 모두 고르시오**

ⓐ var computer-science;

ⓑ var $hello;

ⓒ var new;

ⓓ var _name;

ⓔ var 0score;

a => 2번쨰 글자 이후에는 영문자, 달러, 언더 바, 숫자만 가능하다. (x)
    
b => 첫번쨰 글자에 $ 가능하다.(o)
    
c => (o)
    
d => 첫번째 글자에 언더바 가능하다.(o)
    
e => 변수의 첫번째 글자에는 영문자, $, 언더바만 가능하다.


- **다음 중 결과가 올바른 것은?**

① NaN === NaN : true 

② 5 != ‘5’ : false

③ -0 === +0 : false

④ isNaN(10) : true

⑤ 0 == ‘’ : false

1번 => false
    
2번 => false
    
3번 => true
    
4번 => false
    
5번 => true

-  **다음 코드 실행 결과는 ?**
    
- -3** 2;
    
==> 오류 => 음수는 괄호로 감싸야 한다.
    
-  **다음 코드 실행 결과는 ?**

console.log(typeof NaN);
    
==>number
    
console.log(typeof undefined);
    
==>undefinded
    
console.log(typeof new Array());
    
==>object
    
console.log(typeof function() {});
    
==>function
    
console.log(typeof null);
    
==> object


</code>





https://user-images.githubusercontent.com/79883776/178311896-840e0ec7-47d5-489c-a2f1-5e98760ce2db.mp4

